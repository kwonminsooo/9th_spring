- **지연로딩과 즉시로딩의 차이**

  지연 로딩과 즉시 로딩은 엔티티가 데이터베이스에서 연관된 데이터를 가져오는 시점을 의미한다. 즉시 로딩은 엔티티를 조회할 때 연관된 엔티티도 함께 조회하는 방식으로, FetchType.EAGER 설정 시 사용된다. 반면 지연 로딩은 실제로 연관 객체가 사용될 때 쿼리를 실행하여 데이터를 불러오는 방식이며 FetchType.LAZY 로 설정한다. 즉시 로딩은 여러 엔티티를 한 번에 가져오기 때문에 쿼리 수가 많아져 N+1 문제가 발생하기 쉽지만, 지연 로딩은 필요한 시점에만 데이터를 불러와 효율적이다. 따라서 실무에서는 대부분 지연 로딩을 기본으로 설정한다.

- **JPQL**


    JPA에서 제공하는 객체 지향 쿼리 언어로, SQL과 달리 데이터베이스의 테이블이 아닌 엔티티 객체를 대상으로 쿼리를 작성한다. SQL은 테이블과 컬럼명을 기준으로 하지만 JPQL은 엔티티명과 필드명을 기준으로 하며, JPA가 이를 실제 SQL로 변환해 실행한다. JPQL은 복잡한 조회나 조건문, 그룹핑, 조인 등을 객체 중심으로 다룰 수 있게 해주며, @Query 어노테이션을 통해 직접 작성할 수 있다.

- **Fetch Join**


    JPQL에서 N+1 문제를 해결하기 위한 방법 중 하나로, 연관된 엔티티를 한 번의 쿼리로 함께 조회할 수 있도록 한다. 예를 들어 `select m from Member m join fetch m.memberFoodList`처럼 작성하면, Member와 연관된 MemberFood를 별도의 추가 쿼리 없이 동시에 가져올 수 있다. 이를 통해 연관 데이터를 지연 로딩하지 않고 즉시 함께 가져오면서도 N+1 문제를 피할 수 있다.

- **@EntityGraph**


    Fetch Join과 유사하게 동작하지만, 애노테이션을 이용해 특정 쿼리 실행 시 함께 로딩할 연관 관계를 명시적으로 설정하는 방식이다. 즉, JPQL을 직접 수정하지 않고도 필요한 연관 엔티티를 한 번에 조회할 수 있다. 예를 들어 `@EntityGraph(attributePaths = {"member", "food"})`처럼 지정하면, 해당 엔티티 조회 시 member와 food도 함께 로딩된다.

- **commit과 flush 차이점**

  commit과 flush의 차이점은 데이터베이스에 실제로 변경 사항이 반영되는 시점이다. flush는 영속성 컨텍스트에 저장된 변경 내용을 데이터베이스에 동기화하는 과정으로, SQL을 실행하지만 아직 트랜잭션이 종료된 것은 아니다. commit은 트랜잭션을 종료하며 flush를 자동으로 수행한 뒤 데이터베이스에 변경을 확정한다. 즉, flush는 변경 내용을 DB에 반영하지만 트랜잭션 내에서만 유효하고, commit은 트랜잭션을 종료하며 변경 사항을 영구적으로 저장한다.

- **QueryDSL, OpenFeign의 QueryDSL**

  QueryDSL은 JPQL을 자바 코드로 타입 안전하게 작성할 수 있게 해주는 쿼리 빌더 라이브러리이다. 문자열 기반의 JPQL보다 컴파일 시점에 오류를 잡을 수 있으며, 동적 쿼리를 구성하기 용이하다. 복잡한 조건을 BooleanBuilder로 조합하거나, 메서드 체이닝을 통해 직관적으로 쿼리를 작성할 수 있다. OpenFeign에서 QueryDSL을 활용하는 경우, 서비스 간 통신 시 동적으로 생성된 조건에 맞춰 데이터를 조회하는 데 사용되기도 한다.

- **N+1 문제 해결할 수 있는 여러 방안들**

  하나의 쿼리로 N개의 엔티티를 조회한 뒤, 각 엔티티마다 다시 추가 쿼리가 실행되어 총 N+1개의 쿼리가 발생하는 현상이다. 해결 방법으로는 Fetch Join을 사용해 한 번에 필요한 데이터를 조회하거나, @EntityGraph를 이용하여 연관 데이터를 미리 로딩하는 방법이 있다.

- **영속 상태의 종류**


    비영속 상태(new/transient)는 아직 영속성 컨텍스트와 관계가 없는 상태로, 단순히 new로 생성된 객체를 의미한다. 영속 상태(managed)는 EntityManager에 의해 관리되고 있는 상태로, 변경 감지와 1차 캐시, 지연 로딩이 모두 적용된다. 준영속 상태(detached)는 한때 영속 상태였지만 detach, clear(), close()0 호출 등으로 관리가 해제된 상태이다. 마지막으로 삭제 상태(removed)는 remove() 메서드 호출을 통해 삭제 예약이 된 상태로, 커밋 시점에 데이터베이스에서도 삭제가 반영된다.